# While a program runs {#intro}

- Processor fetches an instruction from memory

- Processor decodes (figures out which instruction this is)

- Processor executes (does its thing: add two numbers, access mem, check condition, etc.)

- Basics of Von Neumann model;

## Operating System {#OS}

- A body of software that is responsible for making programs easy to run many at a time, allows programs to share memory, interact with devices, and is in charge of making sure the system operates correctly and efficiently in an easy-to-use-manner  

## Virtualization {#virtualization}

- The primary method used by operating systems to make them easy to use

- Using physical resources ( the processor, memory, disk) and transforms it into more general, powerful and easy to use **_virtual_** form of itself  

- Thus, OS are sometimes referred to as a **_virtual machine_**

## System Calls {#system-calls}

- In order to allow users to tell the OS what to do, thus making use of the virtual machine(i.e. running a program, accessing a file),
the OS provices APIs that one can call

- A typical OS exports a few hundred **system calls** that are available to applications.

- OS provides these calls to run programs, access memory, and devices: it is said then that the OS provides a **_standard library_** to applications.

## OS As Resource Manager {#resource-manager}

- Because virtualization allows multiple programs to run thus sharing memory, the OS is sometimes known as a **_resource manager_**

- The resources it manages are the CPU, memory, and disk

- The Os's role is to **manage** these resources

### Figure 2.1: Code That Loops and Prints

```#include <stdio.h>
#include <stdlib.h>
#include <sys/time.h>
#include <assert.h>
#include "common.h"

int
main(int argc, char *argv[])
{
   if (argc != 2) {
      fprintf(stderr, "usage: cpu <string>\n");
      exit(1);
   }
   char *str = argv[1];
   while (1) {
      Spin(1);
      printf("%s\n", str);
   }
   return 0;
}
```

### 2.1 Virtualizing The CPU

- The previous figure renders a call to `Spin()`, which routinely checks the time and returns every one second, and prints out.

- Suppose the file is saved to `cpu.c` along with `common.h`, the illusion of running multiple programs on one single processor can be done by using ampersand in between commands such as

```prompt> ./cpu A & ./cpu B & ./cpu C
```

- The operating system is in charge of this **_illusion_** i.e., the illusion that the system has a very large number of virtual CPUs.

- __Turning a single CPU (or small set of them) into a seemingly infinite number of CPUs and thus allowing many programs to **_seemingly_** run at once is called Virtualizing the CPU__

## 2.2 Virtualizing Memory

- Memory is just an array of bytes; to read memory, one must specify an address to be able to access the data stored there

- To write (update) memory, one must also specify the data to be written to the given address

- Memory is accessed all the time during the run of a program

- Programs keep all of their data structures in memory, and access them through various instructions, like loads and stores or other isntructions that access memory

- Each instruction of the program is in memory as well; thus memory is accessed on each instruction fetch

### Figure 2.3: A Program That Accesses Memory

```#include <unistd.h>
#include <stdio.h>
#include <stdlib.h>
#include "common.h"

int
main(int argc, char *argv[])
{
   int *p = mallac(sizeof(int));
   assert(p != NULL);
   printf((%d) address pointed to be p: %p\n", getpid(), p);
   *p = 0;
   while (1) {
      Spin(1);
      *p = *p + 1;
      printf("(%d) p: %d\n", getpid(), *p);
   }
   return 0;
}
```

- This program allocates some memory by calling `malloc()`.

- Prints out the address of the memory and puts the number `0` into the first slot of the newly allocated memory

- Finally, it loops, delaying for a second and incrementing the value stored at the address held in `p`.

- The PID is unique per running process

### Figure 2.4: Running a Memory Program Multiple Times 

```prompt> ./mem &; ./mem &
[1] 24113
[2] 24114
(24113) address pointed to by p: 0x200000 
(24114) address pointed to by p: 0x200000 
(24113) p: 1
(24114) p: 1
(24114) p: 2
(24113) p: 2
(24113) p: 3
(24114) p: 3
(24113) p: 4
(24114) p: 4
...
```

- Each running program has allocated memory at the same address (`0x200000`), and yet, each seems to be updating the value at `0x200000` indeoendently!

- It is as if each running program has its own provate memory, instead of sharing the same physical memory with other running programs. [^5]

- The OS is **_virtualizing memory_**

- Each process accesses its own provate **_virtual address space_** or **_address space_**, which the OS **somehow** maps onto the physical memory of the machine

- A memory reference within one running program does not affest the address space of other processes (Or the OS itself)

- The running program has physical memory all to itself

- Physical memory is a shared resource managed by the OS

[^5]: For this to work, you need to make sure address-space randomization is disabled; randomization can be a good defense against certin kids of security flaws.  Use this to learn how to break into computer systems via stack-smashing attacks.

## 2.3 Concurrency

- This concept is used to solve the many issues that arrise when working on many things at once (concurrently) in the same program

- The OS is juggling many things at once, first running once process, then another, and so forth; leading into some _deep_ and interesting problems.

### Figure 2.5: A Multi-threaded Program (threads.c)

```#include <stdio.h>
#include <stdlib.h>
#include "common.h"

volatile int counter = 0;
int loops;

void *worker(void *arg) {
   int i;
   for (i = 0; i < loops; i++) {
      counter ++;
   }
   return NULL;
}

int
main(int argc, char *argv[])
{
   if (argc != 2) {
      fprintf(stderr, "usage: threads <value>\n");
      exit(1);
   }
   loops = atoi(argv[1]);
   pthread_t p1, p2;
   printf("Initial value: %d\n", counter);

   Pthread_create(&p1, NULL, worker, NULL);
   Pthread_create(&p2, NULL, worker, NULL);
   Pthread_join(p1, NULL);
   Pthread_join(p2, NULL);
   printf("Final value : %d\n", counter);
   return 0;
}
```

- The `main` program creates two **_threads__** using `Pthread_create()`

- You can think og a thread as a function running within the same memory space as other functions, with more than one of them active at a time.

- In this example, each thread starts running in a routing called `worker()`, in which it simply increments a counter in a loop for `loops` number of time.

- The value of `loops` determines how many times each of the two workers will incremenet the shared counter in a loop

- When the input value of `loops` is set to _N_, we would expect the final output for the program to be _2N_

- When using high numbers, you will get different values; relating to how the instructions are executed: which is one at a time. 

- Three instructions are taking place:

1. Load the value of the counter from memory into a register

2. Increment the value

3. Store the value back into memory

- Because these 3 instructions fo not execute **_atomically_** (all at once), strange things can happen. 

- It is the problem of **_concurrency_** 

### Figure 2.6: A Program That Does I/O (io.c)

```#include <stdio.h>
#include <unistd.h>
#include <assert.h>
#include <fcntl.h>
#include <sys/types.h>

int
main(int argc, char *argv[])
{
   int fd = open("/tmp/file", O_WRONLY | O_CREAT | O_TRUNC, S_IRWXU);
   assert(fd > -1);
   int rc = write(fd, "hello world\n", 13);
   assert(rc == 13);
   close(fd);
   return 0;
}
```

## 2.4 Persistance

- The third major theme of this course is **_persistance_**

- In system memory, data can be easily lost, as devices such as DRAM store values in a **_volatile_** manner; such as power outtage

- The hardware to store data **_persistently_** is **_input/output_** or **_I/O_**

- Hard drives are a common repository for long-lived information, although SSD's are making headway in this arena 

- The software in the OS that usuallu manages the disk is called the **_file system_**; and thus responsible for storing any **_files_** that the user creates in a reliable and efficient manner on the disks of the system.

- The OS does not create a private, virtualized disk for each application

-  