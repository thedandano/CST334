# While a program runs {#intro}

- Processor fetches an instruction from memory

- Processor decodes (figures out which instruction this is)

- Processor executes (does its thing: add two numbers, access mem, check condition, etc.)

- Basics of Von Neumann model;

## Operating System {#OS}

- A body of software that is responsible for making programs easy to run many at a time, allows programs to share memory, interact with devices, and is in charge of making sure the system operates correctly and efficiently in an easy-to-use-manner  

## Virtualization {#virtualization}

- The primary method used by operating systems to make them easy to use

- Using physical resources ( the processor, memory, disk) and transforms it into more general, powerful and easy to use **_virtual_** form of itself  

- Thus, OS are sometimes referred to as a **_virtual machine_**

## System Calls {#system-calls}

- In order to allow users to tell the OS what to do, thus making use of the virtual machine(i.e. running a program, accessing a file),
the OS provices APIs that one can call

- A typical OS exports a few hundred **system calls** that are available to applications.

- OS provides these calls to run programs, access memory, and devices: it is said then that the OS provides a **_standard library_** to applications.

## OS As Resource Manager {#resource-manager}

- Because virtualization allows multiple programs to run thus sharing memory, the OS is sometimes known as a **_resource manager_**

- The resources it manages are the CPU, memory, and disk

- The Os's role is to **manage** these resources

### Figure 2.1: Code That Loops and Prints

```#include <stdio.h>
#include <stdlib.h>
#include <sys/time.h>
#include <assert.h>
#include "common.h"

int
main(int argc, char *argv[])
{
   if (argc != 2) {
      fprintf(stderr, "usage: cpu <string>\n");
      exit(1);
   }
   char *str = argv[1];
   while (1) {
      Spin(1);
      printf("%s\n", str);
   }
   return 0;
}
```

### 2.1 Virtualizing The CPU

- The previous figure renders a call to `Spin()`, which routinely checks the time and returns every one second, and prints out.

- Suppose the file is saved to `cpu.c` along with `common.h`, the illusion of running multiple programs on one single processor can be done by using ampersand in between commands such as

```prompt> ./cpu A & ./cpu B & ./cpu C
```

- The operating system is in charge of this **_illusion_** i.e., the illusion that the system has a very large number of virtual CPUs.

- __Turning a single CPU (or small set of them) into a seemingly infinite number of CPUs and thus allowing many programs to **_seemingly_** run at once is called Virtualizing the CPU__

## 2.2 Virtualizing Memory

- Memory is just an array of bytes; to read memory, one must specify an address to be able to access the data stored there

- To write (update) memory, one must also specify the data to be written to the given address

- Memory is accessed all the time during the run of a program

- Programs keep all of their data structures in memory, and access them through various instructions, like loads and stores or other isntructions that access memory

- Each instruction of the program is in memory as well; thus memory is accessed on each instruction fetch

### Figure 2.3: A Program That Accesses Memory

```#include <unistd.h>
#include <stdio.h>
#include <stdlib.h>
#include "common.h"

int
main(int argc, char *argv[])
{
   int *p = mallac(sizeof(int));
   assert(p != NULL);
   printf((%d) address pointed to be p: %p\n", getpid(), p);
   *p = 0;
   while (1) {
      Spin(1);
      *p = *p + 1;
      printf("(%d) p: %d\n", getpid(), *p);
   }
   return 0;
}
```

- This program allocates some memory by calling `malloc()`.

- Prints out the address of the memory and puts the number `0` into the first slot of the newly allocated memory

- Finally, it loops, delaying for a second and incrementing the value stored at the address held in `p`. 